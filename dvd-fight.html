<!-- 
    --- --- --- --- --- --- --- --- READ ME --- --- --- --- --- --- --- ---
    This is an interactive Twitch chat game developed by NikosiaPhD (on Twitch).

    You will need to edit the settings below before using it.

    Do not distribute this code; refer people to the GitHub repository instead.

    --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
-->

<script>

    // --- --- --- --- --- --- --- --- SETTINGS --- --- --- --- --- --- --- ---
    // ONLY EDIT THE RIGHT SIDE OF THE EQUATION

    // replace "nikosiaphd" with your twitch channel name
    const CHANNEL_NAME = "nikosiaphd"

    // messages from these accounts won't spawn boxes
    const EXCLUDED_CHATTERS = ["soundalerts", "streamelements", "sery_bot", "nightbot"]

    // Adjust how big the boxes are. If 1.0 is a bit small, 1.5 makes it 50% bigger, etc.
    const SCALE = 1.5

    // change "true" to "false" if you don't want the kill feed or the highscore list to show up
    const SHOW_KILL_FEED = true
    const SHOW_HIGHSCORE_LIST = true

    // AFTER THIS LINE YOU SHOULD NOT EDIT ANYTHING UNLESS YOU KNOW WHAT YOU'RE DOING
    // --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

</script>




<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>DVD Twitch Messages</title>
    <style>

        @font-face {
            font-family: cooper-black;
            src: url(cooper-black.ttf);
        }

        html {
            height: 100%;
            width: 100%;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #121212;
            font-family: cooper-black, Lucida Sans, Franklin Gothic Medium,sans-serif;
        }
        
        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .message-box {
            position: absolute;
            background-color: #12121290;
            border: 2px solid #4a4a4a;
            padding: 10px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            text-align: center;
            user-select: none;
        }

        .health-bar {
            width: 100%;
            height: 5px;
            background-color: #4a4a4a;
            margin-bottom: 5px;
            overflow: hidden;
        }

        .health-bar-fill {
            height: 100%;
            background-color: #4ecdc4;
            width: 100%;
            transition: width 0.3s ease;
        }

        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            opacity: 1;
        }

        .dvd-username {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            width: 90%;
            height: 30%;
            margin: 0 auto;
            text-align: center;
            display: flex;
            justify-content: center;
            flex-direction: column;
            align-items: center;
        }

        .dvd-message {
            color: #ddd;
            width: 90%;
            margin: 0 auto 5px auto;
            height: 50%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            overflow: hidden;
        }

        #killfeed {
            position: fixed;
            top: 20px;
            left: 20px;
            /* width: 400px; */
            text-wrap: none;
            max-height: 400px;
            overflow-y: hidden;
            border-radius: 10px;
            padding: 10px;
            color: white;


            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 280px;
            
            font-size: 14px;

            .queue-item {
                /* background-color: #12121290; */
                /* border: 2px solid #4a4a4a; */
                border-radius: 8px;
                padding: 12px 16px;
                font-weight: 500;
                color: #e0e0e0;
                transform: translateY(100%);
                opacity: 0;
                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                position: relative;
                overflow: hidden;
            }

            .queue-item.entering {
                transform: translateY(0);
                opacity: 1;
            }

            .queue-item.exiting {
                transform: translateY(-100%);
                opacity: 0;
                margin-top: -56px;
                padding-top: 0;
                padding-bottom: 0;
                height: 0;
                border: none;
            }

        }


        #highscores {
            position: fixed;
            top: 20px;
            right: 20px;
            margin: 20px;
            min-width: 20vw;
            min-height: 280px;
            text-wrap: none;
            max-height: 400px;
            /* display: flex;
            flex-direction: column; */
            color: white;

        }

            
        .score-item {
            /* background: linear-gradient(135deg, #2a2a2a, #1f1f1f);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px; */
            /* background: #12121290; */

            padding: 12px 16px;
            font-weight: 500;
            min-width: 90%;
            width: 20vw;
            position: absolute;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            opacity: 0;
            transform: translateY(100%);
        }

        .player-name {
            font-weight: 600;
        }

        .player-score {
            font-weight: 700;
            /* min-width: 60px; */
            text-align: right;
        }

        .score-item.visible {
            opacity: 1;
        }

        .score-item.entering {
            transform: translateY(0);
        }

        .score-item.exiting {
            opacity: 0;
            transform: translateY(-100%);
        }

        footer {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #e0e0e077;
            font-size: calc(12px * var(--scale, 1.5));
            text-align: center;
            z-index: 1000;
        }

            
    </style>
</head>
<body>
    <div id="killfeed"></div>
    <div id="highscores"></div>
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/textfit@2.4.0/textFit.min.js"></script>

    <script>

        const container = document.getElementById('container');
        const boxWidth = 150 * SCALE;
        const boxHeight = 100 * SCALE;
        const MAX_HEALTH = 100;

        class MessageBox {
            constructor(x, y, username, text, color) {
                this.username = username;
                this.color = color;

                this.element = document.createElement('div');
                this.element.classList.add('message-box');
                this.element.style.width = `${boxWidth}px`;
                this.element.style.height = `${boxHeight}px`;
                this.element.style.borderColor = color;
                this.element.style.borderWidth = `${SCALE * 2}px`;


                // Create text container
                this.usernameContainer = document.createElement('div');
                this.usernameContainer.classList.add("dvd-username")
                this.usernameContainer.innerText = username;

                // Create text container
                this.textContainer = document.createElement('div');
                this.textContainer.classList.add("dvd-message")
                this.textContainer.style.fontSize = `${SCALE * 15}px`;
                

                // Create health bar
                this.healthBarContainer = document.createElement('div');
                this.healthBarContainer.classList.add('health-bar');
                this.healthBarContainer.style.height = `${SCALE * 5}px`;
                this.healthBarFill = document.createElement('div');
                this.healthBarFill.classList.add('health-bar-fill');
                this.healthBarContainer.appendChild(this.healthBarFill);

               

                this.element.appendChild(this.usernameContainer);
                this.element.appendChild(this.textContainer);
                this.element.appendChild(this.healthBarContainer);


                this.x = x;
                this.y = y;
                this.dx = (Math.random() * 4 - 2);
                this.dy = (Math.random() * 4 - 2);
                this.health = MAX_HEALTH;

                this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
                container.appendChild(this.element);


                this.updateMessage(text);
                textFit(this.usernameContainer);

            }

            updateMessage(text) {

                const MAX_CHAR_LEN = 30;

                if (text.length > MAX_CHAR_LEN) {
                    text = text.substring(0, MAX_CHAR_LEN) + "...";
                }

                this.textContainer.innerText = text;
            }

            updateHealthBar() {
                const healthPercentage = (this.health / MAX_HEALTH) * 100;
                this.healthBarFill.style.width = `${healthPercentage}%`;
                
                // Change color based on health
                if (healthPercentage > 50) {
                    this.healthBarFill.style.backgroundColor = '#4ecdc4';
                } else if (healthPercentage > 25) {
                    this.healthBarFill.style.backgroundColor = '#ffa726';
                } else {
                    this.healthBarFill.style.backgroundColor = '#ff6b6b';
                }
            }

            move() {
                this.x += this.dx;
                this.y += this.dy;

                // Bouncing off walls
                // NOTE: for some reason I need to correct the window measurements by 20px
                if (this.x + boxWidth > window.innerWidth - 20) {
                    this.x = window.innerWidth - boxWidth - 20;
                    this.dx *= -1;
                } else if (this.x < 0) {
                    this.x = 0;
                    this.dx *= -1;
                }

                if (this.y + boxHeight > window.innerHeight - 20) {
                    this.y = window.innerHeight - boxHeight - 20;
                    this.dy *= -1;
                } else if (this.y < 0) {
                    this.y = 0;
                    this.dy *= -1;
                }

                this.element.style.transform = `translate(${this.x}px, ${this.y}px)`;
            }

            heal() {
                this.health = Math.min(MAX_HEALTH, this.health + 0.1 * MAX_HEALTH);
                this.updateHealthBar();
            }

            takeDamage(damage) {
                this.health -= damage;
                this.updateHealthBar();
                return this.health <= 0;
            }

            checkCollision(otherBox) {
                return !(this.x > otherBox.x + boxWidth ||
                    this.x + boxWidth < otherBox.x ||
                    this.y > otherBox.y + boxHeight ||
                    this.y + boxHeight < otherBox.y);
            }

            explode() {
                const midX = this.x + boxWidth / 2;
                const midY = this.y + boxHeight / 2;
                particleSystems.push(new ParticleSystem(midX, midY, this.color));
                container.removeChild(this.element);
                delete messageBoxes[this.username];
            }
        }

        class ParticleSystem {
            constructor(x, y, color) {
                this.particles = [];
                this.createParticles(x, y, color);
            }

            createParticles(x, y, color) {

                const offsetX = Math.random() * 20 - 10;
                const offsetY = Math.random() * 20 - 10;
                
                for (let i = 0; i < 30; i++) {
                    const particle = document.createElement('div');
                    particle.classList.add('particle');
                    particle.style.backgroundColor = color;
                    
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 1;
                    
                    const dx = Math.cos(angle) * speed;
                    const dy = Math.sin(angle) * speed;
                    
                    particle.style.left = `${x + offsetX}px`;
                    particle.style.top = `${y + offsetY}px`;
                    
                    container.appendChild(particle);
                    
                    this.particles.push({
                        element: particle,
                        x: x + offsetX,
                        y: y + offsetY,
                        dx: dx,
                        dy: dy,
                        life: 100,
                        color: color
                    });
                }
            }

            update() {
                this.particles.forEach((particle, index) => {
                    particle.x += particle.dx;
                    particle.y += particle.dy;
                    particle.life--;

                    // Fade out effect
                    const opacity = particle.life / 50;
                    particle.element.style.opacity = opacity;
                    particle.element.style.transform = `scale(${opacity})`;

                    particle.element.style.left = `${particle.x}px`;
                    particle.element.style.top = `${particle.y}px`;

                    if (particle.life <= 0) {
                        container.removeChild(particle.element);
                        this.particles.splice(index, 1);
                    }
                });
            }
        }

        const messageBoxes = {
            // username : boxObject
        };

        const particleSystems = [];

        function onTwitchMessage(username, message, color) {
            const x = Math.random() * (window.innerWidth - boxWidth);
            const y = Math.random() * (window.innerHeight - boxHeight);

            if (messageBoxes[username]) {
                messageBoxes[username].heal();
                messageBoxes[username].updateMessage(message);
            } else {
                const newBox = new MessageBox(x, y, username, message, color);
                messageBoxes[username] = newBox;
            }
        }

        function gameLoop() {
            // Update message box positions
            const usernames = Object.keys(messageBoxes);
            for (let i = 0; i < usernames.length; i++) {
                const boxI = messageBoxes[usernames[i]];
                if (!boxI) continue;
                boxI.move();

                // Check for collisions
                for (let j = i + 1; j < usernames.length; j++) {
                    const boxJ = messageBoxes[usernames[j]];

                    if (!boxJ) continue;


                    if (boxI.checkCollision(boxJ)) {
                        // Calculate damage based on velocity
                        const damageI = Math.abs(boxJ.dx) + Math.abs(boxJ.dy);
                        const damageJ = Math.abs(boxI.dx) + Math.abs(boxI.dy);

                        // Swap velocities
                        const tempDx = boxI.dx;
                        const tempDy = boxI.dy;
                        boxI.dx = boxJ.dx;
                        boxI.dy = boxJ.dy;
                        boxJ.dx = tempDx;
                        boxJ.dy = tempDy;

                        const DAMAGE_MULTIPLIER = 10.0

                        // Apply damage
                        const destroyI = boxI.takeDamage(damageJ * DAMAGE_MULTIPLIER);
                        const destroyJ = boxJ.takeDamage(damageI * DAMAGE_MULTIPLIER);

                        // Create particle system if box is destroyed
                        if (destroyI) {
                            boxI.explode();
                            addKillfeedEntry(boxJ.username, boxJ.color, boxI.username, boxI.color);
                            highscores.addOrUpdatePlayer(boxJ.username, 1);
                            break;
                        }

                        if (destroyJ) {
                            boxJ.explode();
                            addKillfeedEntry(boxI.username, boxI.color, boxJ.username, boxJ.color);
                            highscores.addOrUpdatePlayer(boxI.username, 1);
                            break;
                        }
                    }
                }
            }

            // Update particle systems
            for (let i = particleSystems.length - 1; i >= 0; i--) {
                particleSystems[i].update();
                
                // Remove empty particle systems
                if (particleSystems[i].particles.length === 0) {
                    particleSystems.splice(i, 1);
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // These are some initial boxes to start with before messages from chat come in
        // these three lines can be safely removed
        onTwitchMessage("NikosiaPhD", "Check out my website for more!", "#ff0000")
        onTwitchMessage("Panda", "Chatting heals your box!", "#e34102")
        onTwitchMessage("Joyce", "Send a message to spawn a box!", "#b00b69")



        // Start game loop
        gameLoop();

    </script>

    <script> // # # # Twitch Chat Integration # # #

        let ws;
        let reconnectInterval;
        let reconnectTimeout;


        function connectWebSocket() {
            ws = new WebSocket("wss://irc-ws.chat.twitch.tv:443");


            ws.onopen = () => {
                console.log("Connected to Twitch IRC");
                ws.send("CAP REQ :twitch.tv/tags"); 
                ws.send("NICK justinfan12345"); // Anonymous login
                ws.send(`JOIN #${CHANNEL_NAME}`);


                // Clear any existing reconnect interval
                // if (reconnectInterval) {
                //     clearInterval(reconnectInterval);
                // }

            };

            ws.onmessage = (event) => {
                // console.log(event.data);
                
                if (event.data.startsWith("PING")) {
                    ws.send("PONG :" + event.data.split(":")[1]); // Respond to PING to stay connected
                } else {

                    const tagMatch = event.data.match(/^@(.+?)\s/);
                    const messageMatch = event.data.match(/PRIVMSG #\w+ :(.+)/);
            
                    if (tagMatch && messageMatch) {
                        const tags = Object.fromEntries(tagMatch[1].split(";").map(tag => tag.split("=")));
                        const username = tags["display-name"] || "???";
                        const message = messageMatch[1];
                        const color = tags["color"] || "#4a4a4a";

                        console.log(username, message)

                        if (EXCLUDED_CHATTERS.includes(username.toLowerCase())) {
                            return; // Ignore messages from excluded chatters
                        }
                        onTwitchMessage(username, message, color);
                    }
                }
            };

            ws.onclose = () => {
                console.log("Disconnected from Twitch IRC");
                scheduleReconnect();
            };

            ws.onerror = (error) => {
                console.error("WebSocket Error:", error);
                scheduleReconnect();
            };
        }

        function scheduleReconnect() {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
            }
            reconnectTimeout = setTimeout(() => {
                reconnectWebSocket();
            }, 5000); // Wait 5 seconds before attempting to reconnect
        }

        function reconnectWebSocket() {
            if (ws) {
                ws.close();
            }
            connectWebSocket();
        }

        // Initial connection
        connectWebSocket();


    // END # # # Twitch Chat Integration # # #
    </script> 


    <script> // # # # Kill Feed Queue # # #
        class Queue {
            constructor(containerId, maxSize = 5) {
                this.container = document.getElementById(containerId);
                this.maxSize = maxSize;
                this.items = [];
                this.animationDuration = 400;
            }

            addItem(content) {
                // Create new item element
                const item = document.createElement('div');
                item.className = 'queue-item';
                item.innerHTML = content;
                
                // Add to container
                this.container.appendChild(item);
                this.items.push(item);
                
                // Trigger entrance animation
                setTimeout(() => {
                    item.classList.add('entering');
                }, 10);
                
                // Remove oldest item if queue is full
                if (this.items.length > this.maxSize) {
                    this.removeOldestItem();
                }
            }

            removeOldestItem() {
                if (this.items.length === 0) return;
                
                const oldestItem = this.items.shift();
                oldestItem.classList.add('exiting');
                
                // Remove from DOM after animation
                setTimeout(() => {
                    if (oldestItem.parentNode) {
                        oldestItem.parentNode.removeChild(oldestItem);
                    }
                }, this.animationDuration/2);
            }

            clear() {
                this.items.forEach(item => {
                    item.classList.add('exiting');
                    setTimeout(() => {
                        if (item.parentNode) {
                            item.parentNode.removeChild(item);
                        }
                    }, this.animationDuration);
                });
                this.items = [];
            }
        }

        // Initialize queue
        const killFeed = new Queue('killfeed', 5);

        document.getElementById('killfeed').style.fontSize = `${SCALE * 14}px`;

        const killVerbs = [
            "destroyed", "smashed", "obliterated", "shattered", "crushed",
            "demolished", "wrecked"
        ];

        function addKillfeedEntry(username1, color1, username2, color2) {

            if (!SHOW_KILL_FEED) {
                return; // If kill feed is disabled, do nothing
            }

            if (username1.length > 15) username1 = username1.substring(0, 12) + "...";
            if (username2.length > 15) username2 = username2.substring(0, 12) + "...";

            const randomVerb = killVerbs[Math.floor(Math.random() * killVerbs.length)];
            const entry = `<span style="color: ${color1}">${username1}</span> ${randomVerb} <span style="color: ${color2}">${username2}</span>`;
            killFeed.addItem(entry);
        }

    </script>


    <script> // # # # Highscore List # # #
        class HighscoreList {
            constructor(containerId, displayCount = 5) {
                this.container = document.getElementById(containerId);
                this.displayCount = displayCount;
                this.players = new Map(); // name -> score
                this.displayedElements = new Map(); // name -> DOM element
                this.animationDuration = 500;
                this.itemHeight = 56; // height of each item including margin
            }

            addOrUpdatePlayer(name, points) {

                if (!SHOW_HIGHSCORE_LIST) {
                    return; // If highscore list is disabled, do nothing
                }

                const currentScore = this.players.get(name) || 0;
                this.players.set(name, currentScore + points);
                this.updateDisplay();
            }

            updateDisplay() {
                // Get sorted top players
                const sortedPlayers = Array.from(this.players.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, this.displayCount);

                console.log("Sorted players:", sortedPlayers);

                // Track which players should be displayed
                const shouldDisplay = new Set(sortedPlayers.map(([name]) => name));
                
                // Remove players that are no longer in top 5
                for (const [name, element] of this.displayedElements.entries()) {
                    if (!shouldDisplay.has(name)) {
                        this.removePlayer(name, element);
                    }
                }

                // Update positions and add new players
                sortedPlayers.forEach(([name, score], index) => {
                    let element = this.displayedElements.get(name);
                    
                    if (!element) {
                        element = this.createElement(name, score, index);
                        this.displayedElements.set(name, element);
                        this.container.appendChild(element);
                        
                        // Trigger entrance animation
                        setTimeout(() => {
                            element.classList.add('visible', 'entering');
                        }, 50);
                    } else {
                        // Update existing element
                        const scoreElement = element.querySelector('.player-score').textContent = score;

                    }
                    
                    // Animate to new position
                    this.animateToPosition(element, index);
                });
            }

            createElement(name, score) {

                if (name.length > 15) name = name.substring(0, 12) + "...";

                const element = document.createElement('div');
                element.className = 'score-item';
                element.innerHTML = `
                    <div class="player-name">${name}</div>
                    <div class="player-score">${score}</div>
                `;
                return element;
            }


            animateToPosition(element, index) {
                const targetY = index * this.itemHeight;
                element.style.transform = `translateY(${targetY}px)`;
            }

            removePlayer(name, element) {
                this.displayedElements.delete(name);
                element.classList.add('exiting');
                
                setTimeout(() => {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                }, this.animationDuration);
            }

            clear() {
                this.players.clear();
                for (const [name, element] of this.displayedElements.entries()) {
                    this.removePlayer(name, element);
                }
            }
        }

        // Initialize highscore list
        const highscores = new HighscoreList('highscores', 5);

        document.getElementById('highscores').style.fontSize = `${SCALE * 14}px`;


        const footer = document.createElement('footer');
        footer.textContent = 'Made by NikosiaPhD on Twitch';
        document.body.appendChild(footer);

    </script>


</body>
</html>
